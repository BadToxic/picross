<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize game
randomize();
background_hspeed[0] =  0.1;
background_vspeed[0] = -0.1;
background_hspeed[1] = 0.2;
background_vspeed[1] = 0.2;

back_arrow_spr = spr_picross_arrow_left;
mark_sprite = spr_picross_mark;
mark_false_sprite = spr_picross_mark_false;

use_ui_nodes = true;

view = 0;   // 0: Main Menu, 1: InGame


fields_x = 10;
fields_y = 5;
hard_lines_all = 5; // Draw hard_lines_all 5 fields for better visual seperation
ui_nodes = noone;

event_user(0); // Set positions and sizes

game_field = noone;
game_field_clicked = noone;
ui_nodes = noone;
solution = noone;
row_numbers = noone;
column_numbers = noone;

picross_start_new_game(); // Create game structures and start
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for changing window sizes and display orientations
if (view_wview[0] != window_get_width() || view_hview[0] != window_get_height()) {
    event_user(0); // Recalculate sizes
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set positions and sizes
view_wview[0] = window_get_width();
view_hview[0] = window_get_height();

negative_button_width = view_wview[0] / 7;
number_size = 12;
field_size = round(min((view_wview[0] - 2 * negative_button_width) / fields_x,
                       (view_hview[0] - negative_button_width) / fields_y));

if (view == 0) {
    // TODO
}


field_size2 = field_size / 2;

game_area_w  = fields_x * field_size;
game_area_h  = fields_y * field_size;
game_area_x1 = view_xview[0] + (view_wview[0] - negative_button_width) / 2 - game_area_w / 2 + negative_button_width + 3 * number_size;
game_area_y1 = view_yview[0] + view_hview[0] / 2 - game_area_h / 2 + 3 * number_size;
game_area_x2 = game_area_x1 + game_area_w;
game_area_y2 = game_area_y1 + game_area_h;

game_area_mx = game_area_x1 + game_area_w / 2;
game_area_my = game_area_y1 + game_area_h / 2;

back_button_x1 = view_xview[0] - 8;
back_button_y1 = view_yview[0] - 8;
back_button_x2 = view_xview[0] + negative_button_width;
back_button_y2 = back_button_x1 + negative_button_width;
back_button_icon_scale = (negative_button_width - 16) / sprite_get_width(back_arrow_spr);
back_button_icon_x = back_button_x1 + 8 + negative_button_width / 2;
back_button_icon_y = back_button_y1 + (back_button_y2 - back_button_y1) / 2;

negative_button_x1 = back_button_x1;
negative_button_y1 = view_yview[0] + view_hview[0] / 2;
negative_button_x2 = back_button_x2;
negative_button_y2 = view_yview[0] + view_hview[0] + 8;
negative_button_icon_scale = (negative_button_width - 16) / sprite_get_width(mark_false_sprite);
negative_button_icon_x = negative_button_x1 + 8 + (negative_button_width - negative_button_icon_scale * sprite_get_width(mark_false_sprite)) / 2;
negative_button_icon_y = negative_button_y1 + (negative_button_y2 - negative_button_y1 - negative_button_icon_scale * sprite_get_height(mark_false_sprite)) / 2;

if (use_ui_nodes) {
    if (ui_nodes != noone) {
        picross_reposition_ui_nodes(game_field);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Back button
if (view &gt; 0) {
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    
    var xx, yy;
    
    var back = false;
    if (keyboard_check_pressed(vk_escape) || keyboard_check_pressed(vk_backspace)) {
        back = true;
    } else {
        for (var mouse_index = 0; mouse_index &lt; 5; mouse_index++) {
            if (device_mouse_check_button_pressed(mouse_index, mb_left)) {
                if (device_mouse_x(mouse_index) &lt;= back_button_x2) {
                    if (device_mouse_y(mouse_index) &lt;= back_button_y2) {
                        back = true;
                    }
                }
            }
        }
    }
    
    draw_set_alpha(0.7);
    draw_roundrect_colour(back_button_x1, back_button_y1, back_button_x2, back_button_y2, c_gray, c_dkgray, false);
    draw_roundrect(back_button_x1, back_button_y1, back_button_x2, back_button_y2, true);
    draw_set_alpha(1);
    draw_sprite_ext(back_arrow_spr, 0, back_button_icon_x, back_button_icon_y, back_button_icon_scale, back_button_icon_scale, 0, c_white, draw_get_alpha());
    
    if (back) {
        if (view &gt; 0) {
            view--;
            event_user(0); // Recalculate positions and sizes
        } else {
            game_end();
        }
    }
    
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Negative button
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

var xx, yy;

var negate = false;
if (keyboard_check(vk_control)) {
    negate = true;
} else {
    for (var mouse_index = 0; mouse_index &lt; 5; mouse_index++) {
        if (device_mouse_check_button(mouse_index, mb_left)) {
            if (device_mouse_x(mouse_index) &lt;= negative_button_x2) {
                if (device_mouse_y(mouse_index) &gt;= negative_button_y1) {
                    negate = true;
                }
            }
        }
    }
}
if (negate) {
    draw_set_alpha(0.7);
} else {
    draw_set_alpha(0.5);
}
draw_roundrect_colour(negative_button_x1, negative_button_y1, negative_button_x2, negative_button_y2, c_gray, c_dkgray, false);
draw_roundrect(negative_button_x1, negative_button_y1, negative_button_x2, negative_button_y2, true);
if (negate) {
    draw_set_alpha(1);
} else {
    draw_set_alpha(0.7);
}
draw_sprite_ext(mark_false_sprite, 0, negative_button_icon_x, negative_button_icon_y, negative_button_icon_scale, negative_button_icon_scale, 0, c_white, draw_get_alpha());

draw_set_alpha(1);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

var xx, yy;
var list;// spr_picross_arrow_left

// Negative button
var negate = false;
if (keyboard_check(vk_control)) {
    negate = true;
} else {
    for (var mouse_index = 0; mouse_index &lt; 5; mouse_index++) {
        if (device_mouse_check_button(mouse_index, mb_left)) {
            if (device_mouse_x(mouse_index) &lt;= negative_button_x2) {
                if (device_mouse_y(mouse_index) &gt;= negative_button_y1) {
                    //if (device_mouse_x(mouse_index) &gt;= negative_button_x1) {  // Screen border
                        //if (device_mouse_y(mouse_index) &lt;= negative_button_y2) {  // Screen border
                            negate = true;
                        //}
                    //}
                }
            }
        }
    }
}
if (negate) {
    draw_set_alpha(0.7);
} else {
    draw_set_alpha(0.5);
}
draw_roundrect_colour(negative_button_x1, negative_button_y1, negative_button_x2, negative_button_y2, c_gray, c_dkgray, false);
draw_roundrect(negative_button_x1, negative_button_y1, negative_button_x2, negative_button_y2, true);
if (negate) {
    draw_set_alpha(1);
} else {
    draw_set_alpha(0.7);
}
draw_sprite_ext(mark_false_sprite, 0, negative_button_icon_x, negative_button_icon_y, negative_button_icon_scale, negative_button_icon_scale, 0, c_white, draw_get_alpha());
draw_set_alpha(1);

// Draw numbers for colums
xx = game_area_x2 - field_size2;
for (var field_index_x = fields_x - 1; field_index_x &gt;= 0; field_index_x--) {
    
    list = column_numbers[field_index_x];
    yy = game_area_y1 - number_size;
    if (ds_list_empty(list)) {
        draw_text(xx, yy, "0");
        yy -= number_size;
    } else {
        for (var number_index = ds_list_size(list) - 1; number_index &gt;= 0; number_index--) {
            draw_text(xx, yy, string(list[| number_index]));
            yy -= number_size;
        }
    }
    
    xx -= field_size;
}

// Draw numbers for rows
yy = game_area_y2 - field_size2;
for (var field_index_y = fields_y - 1; field_index_y &gt;= 0; field_index_y--) {
    
    list = row_numbers[field_index_y];
    xx = game_area_x1 - number_size;
    if (ds_list_empty(list)) {
        draw_text(xx, yy, "0");
        xx -= number_size;
    } else {
        for (var number_index = ds_list_size(list) - 1; number_index &gt;= 0; number_index--) {
            draw_text(xx, yy, string(list[| number_index]));
            xx -= number_size;
        }
    }
    
    yy -= field_size;
}

draw_set_halign(fa_left);
draw_set_valign(fa_top);

var state_changed = false;
// Handle game area
xx = game_area_x2;
for (var field_index_x = fields_x; field_index_x &gt;= 0; field_index_x--) {
    yy = game_area_y2;
    
    for (var field_index_y = fields_y; field_index_y &gt;= 0; field_index_y--) {
        if (field_index_x &lt; fields_x) if (field_index_y &lt; fields_y) {
            var field_state = game_field[field_index_y, field_index_x];
            
            var x1 = xx - field_size + 1;
            var y1 = yy - field_size + 1;
            var x2 = xx - 1;
            var y2 = yy - 1;
            
            var mouse_index = 0;
            
            if (device_mouse_check_button_released(mouse_index, mb_left) || device_mouse_check_button_released(mouse_index, mb_right)) {
                game_field_clicked = picross_clear_array(game_field_clicked);
                click_command = undefined;
            }
            
            if (device_mouse_x(mouse_index) &gt;= x1) {
                if (device_mouse_y(mouse_index) &gt;= y1) {
                    if (device_mouse_x(mouse_index) &lt;= x2 + 1) {
                        if (device_mouse_y(mouse_index) &lt;= y2 + 1) {
                        
                            for (var zoom_index_x = min(field_index_x + 3, fields_x - 1); zoom_index_x &gt;= max(0, field_index_x - 3); zoom_index_x--) {
                                for (var zoom_index_y = min(field_index_y + 3, fields_y - 1); zoom_index_y &gt;= max(0, field_index_y - 3); zoom_index_y--) {
                        
                                    picross_zoom_node(zoom_index_x, zoom_index_y, mouse_index, field_size / 16);
                                    
                                }
                            }                        
                        
                            if (!game_field_clicked[field_index_y, field_index_x]) {
                                if (device_mouse_check_button(mouse_index, mb_left) &amp;&amp; !negate) {
                                
                                    if (is_undefined(click_command)) {
                                        if (field_state == 0) {
                                            click_command = 1;
                                        } else {
                                            click_command = 0;
                                        }
                                    }
                                    
                                    if (click_command == 0) {
                                        if (field_state != 0) {
                                            field_state = 0;
                                            state_changed = true;
                                        }
                                    } else if (click_command == 1) {
                                        if (field_state == 0) {
                                            field_state = 1;
                                            state_changed = true;
                                        }
                                    }
                                    
                                    game_field_clicked[field_index_y, field_index_x] = mouse_index + 1;
                                } else if (device_mouse_check_button(mouse_index, mb_right) || (device_mouse_check_button(mouse_index, mb_left) &amp;&amp; negate)) {
                                
                                    if (is_undefined(click_command)) {
                                        if (field_state == 0) {
                                            click_command = -1;
                                        } else {
                                            click_command = 0;
                                        }
                                    }
                                    
                                    if (click_command == 0) {
                                        if (field_state != 0) {
                                            field_state = 0;
                                            state_changed = true;
                                        }
                                    } else if (click_command == -1) {
                                        if (field_state == 0) {
                                            field_state = -1;
                                            state_changed = true;
                                        }
                                    }
                                
                                    game_field_clicked[field_index_y, field_index_x] = mouse_index + 1;
                                }
                            }
                        }
                    }
                }
            }
            game_field[field_index_y, field_index_x] = field_state;
            
            /*if (field_state == 1) {
                draw_set_alpha(0.8);
                draw_roundrect_colour(x1, y1, x2 - 1, y2 - 1, c_aqua, c_blue, false);
            } else*/ if (field_state == -1) {
                draw_set_alpha(0.4);
                draw_roundrect_colour(x1, y1, x2 - 1, y2 - 1, c_black, c_white, false);
            }
            draw_set_alpha(1);
            
            draw_set_color(c_black);
            if (!use_ui_nodes) {
                draw_rectangle(x1, y1, x2, y2, true);
            }
            
            yy -= field_size;
        }
        
        draw_set_color(c_black);
        if (use_ui_nodes) {
            var n1, n2, n3, n4;
            
            if (field_index_x &lt; fields_x) {
                n1 = ui_nodes[field_index_y, field_index_x];
                n2 = ui_nodes[field_index_y, field_index_x + 1];
                draw_set_alpha(1);
                if (field_index_y &gt; 0 &amp;&amp; field_index_y &lt; fields_y - 1 &amp;&amp; field_index_y mod hard_lines_all == 0) {
                    draw_line_width(n1.x, n1.y, n2.x, n2.y, 3);
                } else {
                    draw_line(n1.x, n1.y, n2.x, n2.y);
                }
            }
            if (field_index_y &lt; fields_y) {
                n1 = ui_nodes[field_index_y, field_index_x];
                n4 = ui_nodes[field_index_y + 1, field_index_x];
                if (field_index_x &gt; 0 &amp;&amp; field_index_x &lt; fields_x - 1 &amp;&amp; field_index_x mod hard_lines_all == 0) {
                    draw_line_width(n1.x, n1.y, n4.x, n4.y, 3);
                } else {
                    draw_line(n1.x, n1.y, n4.x, n4.y);
                }
                if (field_index_x &lt; fields_x) {
                    if (game_field[field_index_y, field_index_x] == 1) {
                        n3 = ui_nodes[field_index_y + 1, field_index_x + 1];
                        draw_sprite_pos(mark_sprite, 0, n1.x_target_start + 8, n1.y_target_start + 8, n2.x_target_start - 8, n2.y_target_start + 8, n3.x_target_start - 8, n3.y_target_start - 8, n4.x_target_start + 8, n4.y_target - 8, 0.4);
                        draw_sprite_pos(mark_sprite, 0, n1.x, n1.y, n2.x, n2.y, n3.x, n3.y, n4.x, n4.y, 0.8);
                    }
                    else if (game_field[field_index_y, field_index_x] == -1) {
                        n3 = ui_nodes[field_index_y + 1, field_index_x + 1];
                        draw_sprite_pos(mark_false_sprite, 0, n1.x, n1.y, n2.x, n2.y, n3.x, n3.y, n4.x, n4.y, 0.5);
                    }
                }
            }
        }
        
    }
    if (field_index_x &lt; fields_x) {
        xx -= field_size;
    }
}

// State changed - check for win
if (state_changed) {
    if (picross_check_if_solved(game_field, solution)) {
        show_message("SOLVED!");
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="8">
      <action>
        <libid>1</libid>
        <id>601</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_execute_script</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>9</kind>
            <script>picross_start_new_game</script>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
