<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize game
version = "2016.06.11";
author = "BadToxic";
randomize();
draw_set_font(fnt_picross_default); // Needed for HTML5
background_hspeed[0] =  0.1;
background_vspeed[0] = -0.1;
background_hspeed[1] = 0.2;
background_vspeed[1] = 0.2;

back_arrow_spr = spr_picross_arrow_left;
play_spr = spr_picross_play;
mark_sprite = spr_picross_mark;
mark_false_sprite = spr_picross_mark_false;

solved_text = "SOLVED";

use_ui_nodes = true;

view = 0;   // 0: Main Menu, 1: InGame
hold_negate = os_browser == browser_not_a_browser; // If true, you have to hold the negate button, else it toggles
negate = false;

// Controlls
negate_key = vk_control;
exit_key = vk_escape;
back_key = vk_backspace;
start_key = vk_enter;
left_key = vk_left;
right_key = vk_right;
up_key = vk_up;
down_key = vk_down;

// Available game area sizes
game_area_sizes = ds_list_create();
ds_list_add(game_area_sizes, 5, 7, 10, 15, 20);

picross_choose_random_game_area_size();
hard_lines_all = 5; // Draw hard_lines_all 5 fields for better visual seperation
ui_nodes = noone;

event_user(0); // Set positions and sizes

game_field = noone;
game_field_clicked = noone;
ui_nodes = noone;
solution = noone;
row_numbers = noone;
column_numbers = noone;

picross_start_new_game(fields_x, fields_y); // Create game structures and start
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for changing window sizes and display orientations

if (os_browser != browser_not_a_browser) {
    if (browser_width != window_get_width() || browser_height != window_get_height()) {
        event_user(0); // Recalculate sizes
    } 
} 
else if (view_wview[0] != window_get_width() || view_hview[0] != window_get_height()) {
    event_user(0); // Recalculate sizes
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Timer
if (view &gt; 0) {
    if (!is_solved) {
        time += delta_time / 1000000;
        time_str = seconds_2_time(time);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set positions and sizes
if (os_browser != browser_not_a_browser) {
    window_set_size(browser_width, browser_height);
    window_center();
}

view_wview[0] = window_get_width();
view_hview[0] = window_get_height();
view_wport[0] = view_wview[0];
view_hport[0] = view_hview[0];


surface_resize(application_surface, view_wview[0], view_hview[0]);

negative_button_width = round(view_wview[0] / 7);
number_size = 12;
field_size = round(min((view_wview[0] - 2 * negative_button_width) / fields_x,
                       (view_hview[0] - negative_button_width) / fields_y));

if (view == 0) { // Only the half size in the main menu
    field_size = field_size / 2;
}


field_size2 = field_size / 2;

game_area_w  = fields_x * field_size;
game_area_h  = fields_y * field_size;

if (view == 0) {
    // Mini game area in main menu
    game_area_x1 = round(view_xview[0] + view_wview[0] - negative_button_width / 2 - game_area_w);
    game_area_y1 = round(view_yview[0] + view_hview[0] - game_area_h - negative_button_width / 2 + 3 * number_size);
} else {
    game_area_x1 = round(view_xview[0] + (view_wview[0] - negative_button_width) / 2 - game_area_w / 2 + negative_button_width + 3 * number_size);
    game_area_y1 = round(view_yview[0] + (view_hview[0] - game_area_h) / 2 + 3 * number_size);
}

game_area_x2 = game_area_x1 + game_area_w;
game_area_y2 = game_area_y1 + game_area_h;

game_area_mx = round(game_area_x1 + game_area_w / 2);
game_area_my = round(game_area_y1 + game_area_h / 2);

play_button_size = round(min(view_wview[0] / 2 - negative_button_width, view_hview[0] / 2 - negative_button_width));
play_button_x1 = round(view_xview[0] + 0.75 * view_wview[0] - play_button_size / 2);
play_button_y1 = round(view_yview[0] + 0.25 * view_hview[0] - play_button_size / 2);
play_button_x2 = play_button_x1 + play_button_size;
play_button_y2 = play_button_y1 + play_button_size;
play_button_icon_scale = play_button_size / sprite_get_width(play_spr);
play_button_icon_x = round(play_button_x1 + play_button_size / 2);
play_button_icon_y = round(play_button_y1 + play_button_size / 2);

back_button_x1 = view_xview[0] - 8;
back_button_y1 = view_yview[0] - 8;
back_button_x2 = view_xview[0] + negative_button_width;
back_button_y2 = back_button_x1 + negative_button_width;
back_button_icon_scale = (negative_button_width - 16) / sprite_get_width(back_arrow_spr);
back_button_icon_x = round(back_button_x1 + 8 + negative_button_width / 2);
back_button_icon_y = round(back_button_y1 + (back_button_y2 - back_button_y1) / 2);

negative_button_x1 = back_button_x1;
negative_button_y1 = round(view_yview[0] + view_hview[0] / 2);
negative_button_x2 = back_button_x2;
negative_button_y2 = view_yview[0] + view_hview[0] + 8;
negative_button_icon_scale = (negative_button_width - 16) / sprite_get_width(mark_false_sprite);
negative_button_icon_x = round(negative_button_x1 + 8 + (negative_button_width - negative_button_icon_scale * sprite_get_width(mark_false_sprite)) / 2);
negative_button_icon_y = round(negative_button_y1 + (negative_button_y2 - negative_button_y1 - negative_button_icon_scale * sprite_get_height(mark_false_sprite)) / 2);

size_chooser_x1 = round(negative_button_x2 + negative_button_width / 2);
size_chooser_y1 = play_button_y1;
size_chooser_x2 = round(view_xview[0] + (view_wview[0] - negative_button_width) / 2);
size_chooser_y2 = round(view_yview[0] + view_hview[0] - negative_button_width / 2);
size_button_width = round((size_chooser_x2 - size_chooser_x1) / 2);
size_button_width2 = round(size_button_width / 2);
size_button_height = round((size_chooser_y2 - size_chooser_y1) / ds_list_size(game_area_sizes));
size_button_height2 = round(size_button_height / 2);

if (use_ui_nodes) {
    if (is_array(ui_nodes)) {
        picross_reposition_ui_nodes(game_field);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Game area size chooser
if (view == 0) {
    
    // Check surface size
    /*if (surface_exists(application_surface)) {
        draw_text(2, 2, string(surface_get_width(application_surface)) + " x " + string(surface_get_height(application_surface)));
    }*/    
    
    // Choose game area size via keyboard
    if (keyboard_check_pressed(left_key)) {
        var size_index = ds_list_find_index(game_area_sizes, fields_x);
        if (size_index &gt; 0) {
            picross_start_new_game(ds_list_find_value(game_area_sizes, size_index - 1), fields_y);
            event_user(0); // Match sizes to new game area
        }
    } else if (keyboard_check_pressed(right_key)) {
        var size_index = ds_list_find_index(game_area_sizes, fields_x);
        if (size_index &lt; ds_list_size(game_area_sizes) - 1) {
            picross_start_new_game(ds_list_find_value(game_area_sizes, size_index + 1), fields_y);
            event_user(0); // Match sizes to new game area
        }
    } else if (keyboard_check_pressed(up_key)) {
        var size_index = ds_list_find_index(game_area_sizes, fields_y);
        if (size_index &gt; 0) {
            picross_start_new_game(fields_x, ds_list_find_value(game_area_sizes, size_index - 1));
            event_user(0); // Match sizes to new game area
        }
    } else if (keyboard_check_pressed(down_key)) {
        var size_index = ds_list_find_index(game_area_sizes, fields_y);
        if (size_index &lt; ds_list_size(game_area_sizes) - 1) {
            picross_start_new_game(fields_x, ds_list_find_value(game_area_sizes, size_index + 1));
            event_user(0); // Match sizes to new game area
        }
    }
    
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    
    var xx, yy;
    
    xx = size_chooser_x1;
    for (var size_row_index = 0; size_row_index &lt; 2; size_row_index++) {
        yy = size_chooser_y1;
        for (var size_index = 0; size_index &lt; ds_list_size(game_area_sizes); size_index++) {
            var size = game_area_sizes[|size_index];    
        

            for (var mouse_index = 0; mouse_index &lt; 5; mouse_index++) {
                if (device_mouse_check_button_pressed(mouse_index, mb_left)) {
                    if (device_mouse_x(mouse_index) &gt; xx) {
                        if (device_mouse_y(mouse_index) &gt; yy) {
                            if (device_mouse_x(mouse_index) &lt; xx + size_button_width) {
                                if (device_mouse_y(mouse_index) &lt; yy + size_button_height) {
                                    if (size_row_index == 0) {
                                        picross_start_new_game(size, fields_y);
                                        event_user(0); // Match sizes to new game area
                                    } else {
                                        picross_start_new_game(fields_x, size);
                                        event_user(0); // Match sizes to new game area
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            if (size_row_index == 0 &amp;&amp; size == fields_x || size_row_index == 1 &amp;&amp; size == fields_y) {
                draw_set_alpha(0.6);
                draw_roundrect_colour(xx + 1, yy + 1, xx + size_button_width - 1, yy + size_button_height - 1, c_gray, c_dkgray, false);
            } else {
                draw_set_alpha(1);
            }
            draw_roundrect(xx + 1, yy + 1, xx + size_button_width - 1, yy + size_button_height - 1, true);
            draw_text(xx + size_button_width2, yy + size_button_height2, string(size));
            
            yy += size_button_height;
        }
        xx += size_button_width;
    }
    
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_alpha(1);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Play button
if (view == 0) {
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    
    var xx, yy;
    
    var play = false;
    if (keyboard_check_pressed(exit_key) || keyboard_check_pressed(back_key)) {
        back = true;
    } else if (keyboard_check_pressed(start_key)) {
        play = true;
    } else {
        for (var mouse_index = 0; mouse_index &lt; 5; mouse_index++) {
            if (device_mouse_check_button_pressed(mouse_index, mb_left)) {
                if (device_mouse_x(mouse_index) &gt;= play_button_x1) {
                    if (device_mouse_y(mouse_index) &gt;= play_button_y1) {
                        if (device_mouse_x(mouse_index) &lt;= play_button_x2) {
                            if (device_mouse_y(mouse_index) &lt;= play_button_y2) {
                                play = true;
                            }
                        }
                    }
                }
            }
        }
    }
    
    draw_set_alpha(0.7);
    draw_roundrect_colour(play_button_x1, play_button_y1, play_button_x2, play_button_y2, c_gray, c_dkgray, false);
    draw_roundrect(play_button_x1, play_button_y1, play_button_x2, play_button_y2, true);
    draw_set_alpha(1);
    draw_sprite_ext(play_spr, 0, play_button_icon_x, play_button_icon_y, play_button_icon_scale, play_button_icon_scale, 0, c_white, draw_get_alpha());
    
    if (play) {
        if (view == 0) {
            view++;
            mouse_clear(mb_left);
            event_user(0); // Recalculate positions and sizes
        }
    }
    
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Back button
if (view &gt; 0) {
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    
    var xx, yy;
    
    var back = false;
    if (keyboard_check_pressed(vk_escape) || keyboard_check_pressed(vk_backspace)) {
        back = true;
    } else {
        for (var mouse_index = 0; mouse_index &lt; 5; mouse_index++) {
            if (device_mouse_check_button_pressed(mouse_index, mb_left)) {
                if (device_mouse_x(mouse_index) &lt;= back_button_x2) {
                    if (device_mouse_y(mouse_index) &lt;= back_button_y2) {
                        back = true;
                    }
                }
            }
        }
    }
    
    draw_set_alpha(0.7);
    draw_roundrect_colour(back_button_x1, back_button_y1, back_button_x2, back_button_y2, c_gray, c_dkgray, false);
    draw_roundrect(back_button_x1, back_button_y1, back_button_x2, back_button_y2, true);
    draw_set_alpha(1);
    draw_sprite_ext(back_arrow_spr, 0, back_button_icon_x, back_button_icon_y, back_button_icon_scale, back_button_icon_scale, 0, c_white, draw_get_alpha());
    
    if (back) {
        if (view &gt; 0) {
            view--;
            event_user(0); // Recalculate positions and sizes
        } else {
            game_end();
        }
    }
    
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Negative button
if (hold_negate) {
    negate = false; // Reset it every frame
}
if (keyboard_check(negate_key)) {
    if (hold_negate) {
        negate = true;
    } else if (keyboard_check_pressed(negate_key)) {
        negate = !negate;
    }
} else {
    for (var mouse_index = 0; mouse_index &lt; 5; mouse_index++) {
        if (device_mouse_x(mouse_index) &lt;= negative_button_x2) {
            if (device_mouse_y(mouse_index) &gt;= negative_button_y1) {
                //if (device_mouse_x(mouse_index) &gt;= negative_button_x1) {  // Screen border
                    //if (device_mouse_y(mouse_index) &lt;= negative_button_y2) {  // Screen border
                        if (device_mouse_check_button(mouse_index, mb_left)) {
                            if (hold_negate) {
                                negate = true;
                            } else if (device_mouse_check_button_pressed(mouse_index, mb_left)) {
                                negate = !negate;
                            }
                        }
                    //}
                //}
            }
        }
    }
}
if (negate) {
    draw_set_alpha(0.7);
} else {
    draw_set_alpha(0.5);
}
draw_roundrect_colour(negative_button_x1, negative_button_y1, negative_button_x2, negative_button_y2, c_gray, c_dkgray, false);
draw_roundrect(negative_button_x1, negative_button_y1, negative_button_x2, negative_button_y2, true);
if (negate) {
    draw_set_alpha(1);
} else {
    draw_set_alpha(0.7);
}
draw_sprite_ext(mark_false_sprite, 0, negative_button_icon_x, negative_button_icon_y, negative_button_icon_scale, negative_button_icon_scale, 0, c_white, draw_get_alpha());
draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw game area
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

var xx, yy;
var list;// spr_picross_arrow_left


// Draw numbers for colums
xx = game_area_x2 - field_size2;
for (var field_index_x = fields_x - 1; field_index_x &gt;= 0; field_index_x--) {
    
    list = column_numbers[field_index_x];
    yy = game_area_y1 - number_size;
    if (ds_list_empty(list)) {
        draw_text(xx, yy, "0");
        yy -= number_size;
    } else {
        for (var number_index = ds_list_size(list) - 1; number_index &gt;= 0; number_index--) {
            draw_text(xx, yy, string(list[| number_index]));
            yy -= number_size;
        }
    }
    
    xx -= field_size;
}

// Draw numbers for rows
yy = game_area_y2 - field_size2;
for (var field_index_y = fields_y - 1; field_index_y &gt;= 0; field_index_y--) {
    
    list = row_numbers[field_index_y];
    xx = game_area_x1 - number_size;
    if (ds_list_empty(list)) {
        draw_text(xx, yy, "0");
        xx -= number_size;
    } else {
        for (var number_index = ds_list_size(list) - 1; number_index &gt;= 0; number_index--) {
            draw_text(xx, yy, string(list[| number_index]));
            xx -= number_size;
        }
    }
    
    yy -= field_size;
}

var state_changed = false;
// Handle game area
xx = game_area_x2;
for (var field_index_x = fields_x; field_index_x &gt;= 0; field_index_x--) {
    yy = game_area_y2;
    
    for (var field_index_y = fields_y; field_index_y &gt;= 0; field_index_y--) {
        if (field_index_x &lt; fields_x) if (field_index_y &lt; fields_y) {
            var field_state = game_field[field_index_y, field_index_x];
            
            var x1 = xx - field_size + 1;
            var y1 = yy - field_size + 1;
            var x2 = xx - 1;
            var y2 = yy - 1;
            
            var mouse_index = 0;
            
            if (device_mouse_check_button_released(mouse_index, mb_left) || device_mouse_check_button_released(mouse_index, mb_right)) {
                game_field_clicked = picross_clear_array(game_field_clicked);
                click_command = undefined;
            }
            
            if (view &gt; 0 &amp;&amp; !is_solved) { // Only inGame
                if (device_mouse_x(mouse_index) &gt;= x1) {
                    if (device_mouse_y(mouse_index) &gt;= y1) {
                        if (device_mouse_x(mouse_index) &lt;= x2 + 1) {
                            if (device_mouse_y(mouse_index) &lt;= y2 + 1) {
                            
                                for (var zoom_index_x = min(field_index_x + 3, fields_x - 1); zoom_index_x &gt;= max(0, field_index_x - 3); zoom_index_x--) {
                                    for (var zoom_index_y = min(field_index_y + 3, fields_y - 1); zoom_index_y &gt;= max(0, field_index_y - 3); zoom_index_y--) {
                            
                                        picross_zoom_node(zoom_index_x, zoom_index_y, mouse_index, field_size / 16);
                                        
                                    }
                                }                        
                            
                                if (!game_field_clicked[field_index_y, field_index_x]) {
                                    if (device_mouse_check_button(mouse_index, mb_left) &amp;&amp; !negate) {
                                    
                                        if (is_undefined(click_command)) {
                                            if (field_state == 0) {
                                                click_command = 1;
                                            } else {
                                                click_command = 0;
                                            }
                                        }
                                        
                                        if (click_command == 0) {
                                            if (field_state != 0) {
                                                field_state = 0;
                                                state_changed = true;
                                            }
                                        } else if (click_command == 1) {
                                            if (field_state == 0) {
                                                field_state = 1;
                                                state_changed = true;
                                            }
                                        }
                                        
                                        game_field_clicked[field_index_y, field_index_x] = mouse_index + 1;
                                    } else if (device_mouse_check_button(mouse_index, mb_right) || (device_mouse_check_button(mouse_index, mb_left) &amp;&amp; negate)) {
                                    
                                        if (is_undefined(click_command)) {
                                            if (field_state == 0) {
                                                click_command = -1;
                                            } else {
                                                click_command = 0;
                                            }
                                        }
                                        
                                        if (click_command == 0) {
                                            if (field_state != 0) {
                                                field_state = 0;
                                                state_changed = true;
                                            }
                                        } else if (click_command == -1) {
                                            if (field_state == 0) {
                                                field_state = -1;
                                                state_changed = true;
                                            }
                                        }
                                    
                                        game_field_clicked[field_index_y, field_index_x] = mouse_index + 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            game_field[field_index_y, field_index_x] = field_state;
            
            /*if (field_state == 1) {
                draw_set_alpha(0.8);
                draw_roundrect_colour(x1, y1, x2 - 1, y2 - 1, c_aqua, c_blue, false);
            } else*/ if (field_state == -1) {
                draw_set_alpha(0.4);
                draw_roundrect_colour(x1, y1, x2 - 1, y2 - 1, c_black, c_white, false);
            }
            draw_set_alpha(1);
            
            draw_set_color(c_black);
            if (!use_ui_nodes) {
                draw_rectangle(x1, y1, x2, y2, true);
            }
            
            yy -= field_size;
        }
        
        draw_set_color(c_black);
        if (use_ui_nodes) {
            var n1, n2, n3, n4;
            
            if (field_index_x &lt; fields_x) {
                n1 = ui_nodes[field_index_y, field_index_x];
                n2 = ui_nodes[field_index_y, field_index_x + 1];
                draw_set_alpha(1);
                if (field_index_y &gt; 0 &amp;&amp; field_index_y &lt; fields_y - 1 &amp;&amp; field_index_y mod hard_lines_all == 0) {
                    draw_line_width(n1.x, n1.y, n2.x, n2.y, 3);
                } else {
                    draw_line(n1.x, n1.y, n2.x, n2.y);
                }
            }
            if (field_index_y &lt; fields_y) {
                n1 = ui_nodes[field_index_y, field_index_x];
                n4 = ui_nodes[field_index_y + 1, field_index_x];
                if (field_index_x &gt; 0 &amp;&amp; field_index_x &lt; fields_x - 1 &amp;&amp; field_index_x mod hard_lines_all == 0) {
                    draw_line_width(n1.x, n1.y, n4.x, n4.y, 3);
                } else {
                    draw_line(n1.x, n1.y, n4.x, n4.y);
                }
                if (field_index_x &lt; fields_x) {
                    if (game_field[field_index_y, field_index_x] == 1) {
                        n3 = ui_nodes[field_index_y + 1, field_index_x + 1];
                        draw_sprite_pos(mark_sprite, 0, n1.x_target_start + 8, n1.y_target_start + 8, n2.x_target_start - 8, n2.y_target_start + 8, n3.x_target_start - 8, n3.y_target_start - 8, n4.x_target_start + 8, n4.y_target - 8, 0.4);
                        draw_sprite_pos(mark_sprite, 0, n1.x, n1.y, n2.x, n2.y, n3.x, n3.y, n4.x, n4.y, 0.8);
                    }
                    else if (game_field[field_index_y, field_index_x] == -1) {
                        n3 = ui_nodes[field_index_y + 1, field_index_x + 1];
                        draw_sprite_pos(mark_false_sprite, 0, n1.x, n1.y, n2.x, n2.y, n3.x, n3.y, n4.x, n4.y, 0.5);
                    }
                }
            }
        }
        
    }
    if (field_index_x &lt; fields_x) {
        xx -= field_size;
    }
}


draw_set_valign(fa_top);
// State changed - check for win
if (state_changed) {
    is_solved = picross_check_if_solved(game_field, solution);
    if (is_solved) {
        repeat(8) {
            effect_create_above(ef_firework, view_xview[0] + random(view_wview[0]), view_yview[0] + random(view_hview[0]), irandom(2), make_colour_hsv(255, irandom(255), 120));
        }
    }
}
if (is_solved) {
    draw_text(view_xview[0] + view_wview[0] / 2 - 2, view_yview[0] + 6, solved_text);
    draw_text_colour(view_xview[0] + view_wview[0] / 2, view_yview[0] + 4, solved_text, c_orange, c_yellow, c_olive, c_yellow, 1);
}


// Draw timer
draw_set_halign(fa_right);
draw_text(view_xview[0] + view_wview[0] - 4, view_yview[0] + 4, time_str);
// Draw author and version date
draw_set_halign(fa_center);
draw_set_valign(fa_bottom);
draw_text(view_xview[0] + view_wview[0] / 2, view_yview[0] + view_hview[0] - 2, author + " - " + version);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="115">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Switch fullscreen
window_set_fullscreen(!window_get_fullscreen());
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
